<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D RPG World</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            z-index: 100;
        }
        #error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(255,0,0,0.7);
            padding: 20px;
            display: none;
            z-index: 100;
        }
        #minimap {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid white;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="info">Click to start<br>WASD to move<br>Mouse to look</div>
    <div id="error"></div>
    
    <script async src="https://unpkg.com/es-module-shims/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import SimplexNoise from 'https://cdn.skypack.dev/simplex-noise@3.0.1';

        let scene, camera, renderer, controls;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let prevTime = performance.now();
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let terrain;
        const simplex = new SimplexNoise();
        let animals = [];
        const PLAYER_HEIGHT = 2;
        let canJump = false;
        let moveUp = false;
        let moveDown = false;
        let dayTime = 0;
        let sunLight, sky;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let hoveredObject = null;
        let interactionText = null;

        try {
            init();
            animate();
        } catch (error) {
            console.error('Initialization error:', error);
            document.getElementById('error').style.display = 'block';
            document.getElementById('error').textContent = 'Error: ' + error.message;
        }

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance"
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            // Create sun and sky
            sunLight = new THREE.DirectionalLight(0xffffff, 1);
            sunLight.position.set(50, 100, 50);
            sunLight.castShadow = true;
            scene.add(sunLight);

            // Enable shadows in renderer
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Add fog
            scene.fog = new THREE.FogExp2(0x87CEEB, 0.002);

            // Controls
            controls = new PointerLockControls(camera, document.body);

            const blocker = document.getElementById('info');

            blocker.addEventListener('click', function () {
                controls.lock();
            });

            controls.addEventListener('lock', function () {
                blocker.style.display = 'none';
            });

            controls.addEventListener('unlock', function () {
                blocker.style.display = 'block';
            });

            // Event listeners
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onWindowResize, false);

            // Create world elements in correct order
            createGround();    // Ground first
            createTerrain();   // Then terrain
            
            // Add trees after terrain is created
            const treeCount = 100;
            for (let i = 0; i < treeCount; i++) {
                const x = Math.random() * 800 - 400;
                const z = Math.random() * 800 - 400;
                const y = getHeightAtPosition(x, z);
                if (y > 0 && y < 20) { // Only place trees at appropriate heights
                    createTree(x, y, z);
                }
            }

            // Add animals
            for (let i = 0; i < 5; i++) {
                const x = Math.random() * 400 - 200;
                const z = Math.random() * 400 - 200;
                const y = getHeightAtPosition(x, z);
                createDeer(x, y, z);
                createPeacock(x + 20, y, z + 20);
            }
            
            // Add birds
            for(let i = 0; i < 10; i++) {
                createBird();
            }

            // Set initial player position at ground level
            const startX = 0;
            const startZ = 50;
            const groundY = getHeightAtPosition(startX, startZ);
            camera.position.set(startX, groundY + PLAYER_HEIGHT, startZ);

            // Create a large lake
            const lake = createLake(50, -50, 30);
            
            // Add ducks to the lake
            for (let i = 0; i < 5; i++) {
                const duck = createDuck();
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 20;
                duck.position.set(
                    50 + Math.cos(angle) * radius,
                    1,
                    -50 + Math.sin(angle) * radius
                );
                scene.add(duck);
                animals.push(duck);
            }
            
            // Add more grass patches
            for (let i = 0; i < 1000; i++) {
                const x = Math.random() * 800 - 400;
                const z = Math.random() * 800 - 400;
                const y = getHeightAtPosition(x, z);
                if (y > 0 && y < 15) { // Only place grass at appropriate heights
                    const grass = createGrass(x, y, z);
                    scene.add(grass);
                }
            }
            
            // Add more trees in denser clusters
            for (let cluster = 0; cluster < 20; cluster++) {
                const centerX = Math.random() * 800 - 400;
                const centerZ = Math.random() * 800 - 400;
                
                for (let i = 0; i < 20; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * 20;
                    const x = centerX + Math.cos(angle) * radius;
                    const z = centerZ + Math.sin(angle) * radius;
                    const y = getHeightAtPosition(x, z);
                    if (y > 0 && y < 20) {
                        createTree(x, y, z, 0.5 + Math.random() * 1);
                    }
                }
            }

            // Add more grass
            for (let i = 0; i < 5000; i++) {
                const x = Math.random() * 800 - 400;
                const z = Math.random() * 800 - 400;
                const y = getHeightAtPosition(x, z);
                if (y > 0 && y < 15) {
                    const grass = createGrass(x, y, z);
                    scene.add(grass);
                }
            }

            // Create river
            const river = createRiver();

            // Add more deer in herds
            for (let herd = 0; herd < 5; herd++) {
                const herdCenterX = Math.random() * 800 - 400;
                const herdCenterZ = Math.random() * 800 - 400;
                
                for (let i = 0; i < 10; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * 20;
                    const x = herdCenterX + Math.cos(angle) * radius;
                    const z = herdCenterZ + Math.sin(angle) * radius;
                    const y = getHeightAtPosition(x, z);
                    createDeer(x, y, z);
                }
            }

            // Add more birds in flocks
            for (let flock = 0; flock < 5; flock++) {
                const flockCenterX = Math.random() * 400 - 200;
                const flockCenterY = 50 + Math.random() * 30;
                const flockCenterZ = Math.random() * 400 - 200;
                
                for (let i = 0; i < 10; i++) {
                    const bird = createBird();
                    bird.position.set(
                        flockCenterX + Math.random() * 20 - 10,
                        flockCenterY + Math.random() * 10 - 5,
                        flockCenterZ + Math.random() * 20 - 10
                    );
                    animals.push(bird);
                }
            }

            // Add dense grass
            for (let patch = 0; patch < 100; patch++) {
                const patchX = Math.random() * 800 - 400;
                const patchZ = Math.random() * 800 - 400;
                
                for (let i = 0; i < 100; i++) {
                    const x = patchX + Math.random() * 20 - 10;
                    const z = patchZ + Math.random() * 20 - 10;
                    const y = getHeightAtPosition(x, z);
                    if (y > 0 && y < 15) {
                        const grass = createGrass(x, y, z);
                        scene.add(grass);
                    }
                }
            }

            // Add minimap
            addMinimapStyles();
            const updateMinimap = createMinimap();

            // Update the animate function to include minimap updates
            const originalAnimate = animate;
            animate = function() {
                originalAnimate();
                updateMinimap();
            };

            // Add dragon
            const dragon = createDragon();
            dragon.position.set(0, 100, 0);
            scene.add(dragon);
            
            // Update animate to include dragon movement
            animate = function() {
                originalAnimate();
                
                // Animate dragon
                if (dragon) {
                    dragon.userData.time += 0.005;
                    const radius = 200;
                    dragon.position.x = Math.cos(dragon.userData.time) * radius;
                    dragon.position.z = Math.sin(dragon.userData.time) * radius;
                    dragon.position.y = dragon.userData.flyingHeight + Math.sin(dragon.userData.time * 2) * 20;
                    dragon.rotation.y = -dragon.userData.time;
                    
                    // Animate wings
                    dragon.children[2].rotation.y = Math.PI / 4 + Math.sin(dragon.userData.time * 10) * 0.2;
                    dragon.children[3].rotation.y = -Math.PI / 4 - Math.sin(dragon.userData.time * 10) * 0.2;
                }
            };

            // Create flower field
            createFlowerField();
            
            // Add interaction text
            interactionText = createInteractionText();
            
            // Add mouse event listeners
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('click', onMouseClick, false);

            console.log('Initialization complete');
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = true;
                    break;
                case 'Space':
                    moveUp = true;
                    break;
                case 'ShiftLeft':
                    moveDown = true;
                    break;
                case 'KeyE':
                    interactWithAnimals();
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = false;
                    break;
                case 'Space':
                    moveUp = false;
                    break;
                case 'ShiftLeft':
                    moveDown = false;
                    break;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (controls.isLocked) {
                const time = performance.now();
                const delta = (time - prevTime) / 1000;

                // Reset horizontal velocity
                velocity.x -= velocity.x * 5.0 * delta;
                velocity.z -= velocity.z * 5.0 * delta;

                // Smoother vertical movement
                if (moveUp) {
                    velocity.y = Math.min(velocity.y + 40.0 * delta, 20.0);
                } else if (moveDown) {
                    velocity.y = Math.max(velocity.y - 40.0 * delta, -20.0);
                } else {
                    velocity.y -= velocity.y * 2.0 * delta; // Gentle drift down
                }

                // Update movement
                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

                // Move camera
                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                camera.position.y += velocity.y * delta;

                // Keep above ground
                const terrainHeight = getHeightAtPosition(camera.position.x, camera.position.z);
                if (camera.position.y < terrainHeight + PLAYER_HEIGHT) {
                    camera.position.y = terrainHeight + PLAYER_HEIGHT;
                    velocity.y = 0;
                }

                prevTime = time;
            }

            // Update raycaster for interactions
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            // Handle hover effects
            if (intersects.length > 0) {
                const object = intersects[0].object;
                if (object.userData.isFlower || object.userData.type) {
                    hoveredObject = object;
                    if (interactionText) {
                        interactionText.style.display = 'block';
                        interactionText.style.left = (event.clientX + 10) + 'px';
                        interactionText.style.top = (event.clientY + 10) + 'px';
                        interactionText.textContent = `Click to interact with ${
                            object.userData.isFlower ? 'flower' : object.userData.type
                        }`;
                    }
                }
            } else {
                hoveredObject = null;
                if (interactionText) {
                    interactionText.style.display = 'none';
                }
            }

            // Update day/night cycle
            dayTime += 0.0002;
            const sunAngle = dayTime % (Math.PI * 2);
            const sunHeight = Math.sin(sunAngle);
            const sunX = Math.cos(sunAngle) * 100;
            const sunY = Math.max(sunHeight * 100, 0);
            
            if (sunLight) {
                sunLight.position.set(sunX, sunY, 0);
                sunLight.intensity = Math.max(sunHeight, 0.2);
            }

            // Update sky color
            const skyColor = new THREE.Color();
            if (sunHeight > 0) {
                skyColor.setRGB(
                    0.529 + sunHeight * 0.1,
                    0.808 + sunHeight * 0.1,
                    0.922 + sunHeight * 0.05
                );
            } else {
                skyColor.setRGB(0.1, 0.1, 0.2);
            }
            scene.background = skyColor;
            if (scene.fog) scene.fog.color = skyColor;

            renderer.render(scene, camera);
        }

        function createTerrain() {
            const geometry = new THREE.PlaneGeometry(1000, 1000, 100, 100);
            geometry.rotateX(-Math.PI / 2);

            const vertices = geometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const z = vertices[i + 2];
                
                let height = 0;
                // Base terrain
                height += simplex.noise2D(x * 0.002, z * 0.002) * 50; // Large features
                height += simplex.noise2D(x * 0.01, z * 0.01) * 10;   // Medium features
                height += simplex.noise2D(x * 0.02, z * 0.02) * 5;    // Small features
                
                vertices[i + 1] = Math.max(0, height); // Ensure minimum height is 0
            }

            geometry.computeVertexNormals();

            // Create material with vertex colors based on height
            const material = new THREE.MeshStandardMaterial({
                vertexColors: true,
                flatShading: true
            });

            // Add vertex colors based on height
            const colors = [];
            for (let i = 0; i < vertices.length; i += 3) {
                const height = vertices[i + 1];
                const color = new THREE.Color();
                
                if (height < 2) {
                    color.setHex(0xc2b280); // Sand color
                } else if (height < 10) {
                    color.setHex(0x90EE90); // Light green (grass)
                } else if (height < 20) {
                    color.setHex(0x228B22); // Forest green
                } else {
                    color.setHex(0x808080); // Mountain gray
                }
                
                colors.push(color.r, color.g, color.b);
            }

            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            terrain = new THREE.Mesh(geometry, material);
            terrain.receiveShadow = true;
            terrain.castShadow = true;
            scene.add(terrain);
        }

        function createTree(x, y, z, scale = 1) {
            const tree = new THREE.Group();

            // Trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.2 * scale, 0.3 * scale, 2 * scale, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4a3728,
                roughness: 0.9 
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            tree.add(trunk);

            // Create multiple layers of leaves
            const leafColors = [0x2d5a27, 0x1a4314, 0x3d7a37];
            for (let i = 0; i < 3; i++) {
                const leafGeometry = new THREE.ConeGeometry(
                    1.2 * scale - (i * 0.3), 
                    2 * scale, 
                    8
                );
                const leafMaterial = new THREE.MeshStandardMaterial({ 
                    color: leafColors[i % leafColors.length],
                    roughness: 0.8
                });
                const leaves = new THREE.Mesh(leafGeometry, leafMaterial);
                leaves.position.y = (1 + i) * scale;
                leaves.castShadow = true;
                leaves.receiveShadow = true;
                tree.add(leaves);
            }

            tree.position.set(x, y, z);
            return tree;
        }

        function getHeightAtPosition(x, z) {
            // Raycast from high above to find terrain height
            const raycaster = new THREE.Raycaster();
            raycaster.ray.direction.set(0, -1, 0);
            raycaster.ray.origin.set(x, 1000, z);
            
            const intersects = raycaster.intersectObject(terrain);
            if (intersects.length > 0) {
                return intersects[0].point.y;
            }
            return 0;
        }

        function createDeer(x, z) {
            const deer = new THREE.Group();
            
            // Body
            const bodyGeometry = new THREE.CapsuleGeometry(0.4, 1.2, 4, 8);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.rotation.z = Math.PI / 2;
            deer.add(body);
            
            // Head
            const headGeometry = new THREE.CapsuleGeometry(0.3, 0.8, 4, 8);
            const head = new THREE.Mesh(headGeometry, bodyMaterial);
            head.position.set(0.8, 0.5, 0);
            head.rotation.z = -Math.PI / 6;
            deer.add(head);
            
            // Antlers (only for some deer)
            if (Math.random() > 0.5) {
                const antlerMaterial = new THREE.MeshPhongMaterial({ color: 0x4A3728 });
                [-1, 1].forEach(side => {
                    const antler = new THREE.Group();
                    const mainBranch = new THREE.CylinderGeometry(0.02, 0.02, 0.5);
                    const mainMesh = new THREE.Mesh(mainBranch, antlerMaterial);
                    mainMesh.rotation.z = Math.PI / 4;
                    antler.add(mainMesh);
                    
                    // Add branches
                    for (let i = 0; i < 3; i++) {
                        const branch = new THREE.CylinderGeometry(0.01, 0.01, 0.3);
                        const branchMesh = new THREE.Mesh(branch, antlerMaterial);
                        branchMesh.position.y = 0.1 + (i * 0.1);
                        branchMesh.rotation.z = Math.PI / 3;
                        antler.add(branchMesh);
                    }
                    antler.position.set(0.9, 0.8, side * 0.15);
                    deer.add(antler);
                });
            }
            
            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1.2);
            const positions = [
                [-0.3, -0.6, 0.3],
                [0.3, -0.6, 0.3],
                [-0.3, -0.6, -0.3],
                [0.3, -0.6, -0.3]
            ];
            
            positions.forEach(pos => {
                const leg = new THREE.Mesh(legGeometry, bodyMaterial);
                leg.position.set(...pos);
                deer.add(leg);
            });
            
            const y = getHeightAtPosition(x, z);
            deer.position.set(x, y + 1.2, z); // Adjust y position based on leg height
            deer.userData.type = 'deer';
            deer.userData.velocity = new THREE.Vector3();
            deer.userData.state = 'idle';
            
            animals.push(deer);
            scene.add(deer);
            return deer;
        }

        function createBird() {
            const bird = new THREE.Group();
            
            // Body
            const bodyGeometry = new THREE.CapsuleGeometry(0.2, 0.4, 4, 8);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x555555 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            bird.add(body);
            
            // Wings
            const wingGeometry = new THREE.PlaneGeometry(0.8, 0.3);
            const wingMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x666666,
                side: THREE.DoubleSide
            });
            
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(-0.4, 0, 0);
            bird.add(leftWing);
            
            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.position.set(0.4, 0, 0);
            bird.add(rightWing);
            
            bird.position.set(
                Math.random() * 200 - 100,
                50 + Math.random() * 30,
                Math.random() * 200 - 100
            );
            
            bird.userData.velocity = new THREE.Vector3(
                Math.random() - 0.5,
                0,
                Math.random() - 0.5
            ).normalize().multiplyScalar(0.5);
            
            scene.add(bird);
            return bird;
        }

        function createPeacock(x, z) {
            const peacock = new THREE.Group();
            
            // Body
            const bodyGeometry = new THREE.CapsuleGeometry(0.3, 0.8, 4, 8);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x000080 }); // Navy blue
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            peacock.add(body);
            
            // Tail feathers
            const featherColors = [0x00FF00, 0x4169E1, 0x000080]; // Green, Royal Blue, Navy
            const featherCount = 12;
            const featherGeometry = new THREE.PlaneGeometry(0.2, 1);
            
            for (let i = 0; i < featherCount; i++) {
                const angle = (i / featherCount) * Math.PI;
                const featherMaterial = new THREE.MeshPhongMaterial({
                    color: featherColors[i % featherColors.length],
                    side: THREE.DoubleSide
                });
                const feather = new THREE.Mesh(featherGeometry, featherMaterial);
                feather.position.set(
                    Math.cos(angle) * 0.5,
                    0.5,
                    Math.sin(angle) * 0.5 - 0.5
                );
                feather.rotation.x = Math.PI / 3;
                feather.rotation.y = angle;
                peacock.add(feather);
            }
            
            // Head and neck
            const headGeometry = new THREE.SphereGeometry(0.15);
            const headMaterial = new THREE.MeshPhongMaterial({ color: 0x000080 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0, 0.6, 0.3);
            peacock.add(head);
            
            // Crown
            const crownGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.2);
            const crownMaterial = new THREE.MeshPhongMaterial({ color: 0x00FF00 });
            for (let i = 0; i < 3; i++) {
                const crown = new THREE.Mesh(crownGeometry, crownMaterial);
                crown.position.set(0, 0.8, 0.3);
                crown.rotation.z = (i / 3) * Math.PI;
                peacock.add(crown);
            }
            
            const y = getHeightAtPosition(x, z);
            peacock.position.set(x, y + 0.5, z);
            peacock.userData.type = 'peacock';
            peacock.userData.velocity = new THREE.Vector3();
            peacock.userData.state = 'idle';
            
            animals.push(peacock);
            scene.add(peacock);
            return peacock;
        }

        function createGround() {
            const groundGeometry = new THREE.PlaneGeometry(2000, 2000);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x355E3B,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -1; // Just below terrain level
            ground.receiveShadow = true;
            
            scene.add(ground);
        }

        function createLake(centerX, centerZ, baseRadius) {
            const points = [];
            const segments = 32;
            
            for (let i = 0; i < segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                // Add noise to radius for irregular shape
                const radius = baseRadius * (1 + 0.3 * simplex.noise2D(Math.cos(angle), Math.sin(angle)));
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                points.push(new THREE.Vector2(x, z));
            }
            
            const lakeShape = new THREE.Shape(points);
            const lakeGeometry = new THREE.ShapeGeometry(lakeShape);
            const lakeMaterial = new THREE.MeshPhongMaterial({
                color: 0x0099ff,
                transparent: true,
                opacity: 0.8,
                shininess: 100
            });
            
            const lake = new THREE.Mesh(lakeGeometry, lakeMaterial);
            lake.rotation.x = -Math.PI / 2;
            lake.position.set(centerX, 0.5, centerZ);
            
            scene.add(lake);
            return lake;
        }

        function createDuck() {
            const duck = new THREE.Group();
            
            // Body
            const bodyGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            duck.add(body);
            
            // Head
            const headGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            const head = new THREE.Mesh(headGeometry, bodyMaterial);
            head.position.set(0.3, 0.2, 0);
            duck.add(head);
            
            // Bill
            const billGeometry = new THREE.ConeGeometry(0.1, 0.2, 4);
            const billMaterial = new THREE.MeshPhongMaterial({ color: 0xFFA500 });
            const bill = new THREE.Mesh(billGeometry, billMaterial);
            bill.rotation.z = Math.PI / 2;
            bill.position.set(0.5, 0.2, 0);
            duck.add(bill);
            
            // Initialize duck properties
            duck.userData.velocity = new THREE.Vector3();
            duck.userData.isSwimming = true;
            duck.userData.swimAngle = Math.random() * Math.PI * 2;
            
            return duck;
        }

        function createGrass(x, y, z) {
            const grass = new THREE.Group();
            
            // Create multiple blades
            const bladeCount = 3;
            const bladeGeometry = new THREE.PlaneGeometry(0.1, 0.5);
            const bladeMaterial = new THREE.MeshPhongMaterial({
                color: 0x3a5a40,
                side: THREE.DoubleSide
            });
            
            for (let i = 0; i < bladeCount; i++) {
                const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                blade.position.set(
                    (Math.random() - 0.5) * 0.2,
                    Math.random() * 0.2,
                    (Math.random() - 0.5) * 0.2
                );
                blade.rotation.y = Math.random() * Math.PI;
                blade.rotation.x = Math.random() * 0.2;
                grass.add(blade);
            }
            
            grass.position.set(x, y, z);
            return grass;
        }

        function createRiver() {
            const riverPoints = [];
            let x = -500;
            let z = -200;
            
            // Create meandering river path that flows to lake
            while (x < 50) { // Lake center X
                const point = new THREE.Vector3(x, 0, z);
                // Add meandering using noise
                z = -200 + simplex.noise2D(x * 0.01, 0) * 50;
                // Gradually curve towards lake
                z += ((-50 - z) / 550) * (x + 500); // Lake center Z is -50
                riverPoints.push(point);
                x += 5;
            }

            // Create variable width river
            const riverShape = new THREE.Shape();
            const width = 15;
            
            riverPoints.forEach((point, i) => {
                const progress = i / riverPoints.length;
                // River gets wider as it approaches lake
                const currentWidth = width * (1 + progress);
                const angle = i < riverPoints.length - 1 
                    ? Math.atan2(riverPoints[i+1].z - point.z, riverPoints[i+1].x - point.x)
                    : Math.atan2(riverPoints[i].z - riverPoints[i-1].z, riverPoints[i].x - riverPoints[i-1].x);
                
                const dx = Math.cos(angle + Math.PI/2) * currentWidth;
                const dz = Math.sin(angle + Math.PI/2) * currentWidth;
                
                if (i === 0) {
                    riverShape.moveTo(point.x + dx, point.z + dz);
                } else {
                    riverShape.lineTo(point.x + dx, point.z + dz);
                }
            });
            
            // Complete the shape
            riverPoints.reverse().forEach((point, i) => {
                const progress = (riverPoints.length - i) / riverPoints.length;
                const currentWidth = width * (1 + progress);
                const angle = i < riverPoints.length - 1 
                    ? Math.atan2(riverPoints[i+1].z - point.z, riverPoints[i+1].x - point.x)
                    : Math.atan2(riverPoints[i].z - riverPoints[i-1].z, riverPoints[i].x - riverPoints[i-1].x);
                
                const dx = Math.cos(angle - Math.PI/2) * currentWidth;
                const dz = Math.sin(angle - Math.PI/2) * currentWidth;
                riverShape.lineTo(point.x + dx, point.z + dz);
            });

            const riverGeometry = new THREE.ShapeGeometry(riverShape);
            const riverMaterial = new THREE.MeshPhongMaterial({
                color: 0x0077be,
                transparent: true,
                opacity: 0.8,
                shininess: 100
            });
            
            const river = new THREE.Mesh(riverGeometry, riverMaterial);
            river.rotation.x = -Math.PI / 2;
            river.position.y = 0.5;
            
            scene.add(river);
            return river;
        }

        function addMinimapStyles() {
            const style = document.createElement('style');
            style.textContent = `
                #minimap {
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    width: 200px;
                    height: 200px;
                    background: rgba(0, 0, 0, 0.5);
                    border: 2px solid white;
                    border-radius: 5px;
                }
            `;
            document.head.appendChild(style);
        }

        function createMinimap() {
            const minimapDiv = document.createElement('div');
            minimapDiv.id = 'minimap';
            document.body.appendChild(minimapDiv);

            const minimapScene = new THREE.Scene();
            const minimapCamera = new THREE.OrthographicCamera(
                -500, 500, 500, -500, 1, 1000
            );
            minimapCamera.position.set(0, 200, 0);
            minimapCamera.lookAt(0, 0, 0);

            const minimapRenderer = new THREE.WebGLRenderer({ alpha: true });
            minimapRenderer.setSize(200, 200);
            minimapDiv.appendChild(minimapRenderer.domElement);

            function createMinimapObjects() {
                // Create heightmap for terrain visualization
                const terrainGeometry = new THREE.PlaneGeometry(1000, 1000, 100, 100);
                const vertices = terrainGeometry.attributes.position.array;
                
                for (let i = 0; i < vertices.length; i += 3) {
                    const x = vertices[i];
                    const z = vertices[i + 2];
                    vertices[i + 1] = getHeightAtPosition(x, z) * 0.5; // Scale height for visualization
                }
                
                const terrainMaterial = new THREE.MeshPhongMaterial({
                    vertexColors: true,
                    wireframe: true
                });
                
                // Add vertex colors based on height
                const colors = [];
                for (let i = 0; i < vertices.length; i += 3) {
                    const height = vertices[i + 1];
                    const color = new THREE.Color();
                    
                    if (height < 2) {
                        color.setHex(0x0077be); // Water
                    } else if (height < 5) {
                        color.setHex(0x90EE90); // Grass
                    } else if (height < 15) {
                        color.setHex(0x228B22); // Forest
                    } else {
                        color.setHex(0x808080); // Mountains
                    }
                    
                    colors.push(color.r, color.g, color.b);
                }
                
                terrainGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                const terrainMesh = new THREE.Mesh(terrainGeometry, terrainMaterial);
                terrainMesh.rotation.x = -Math.PI / 2;
                minimapScene.add(terrainMesh);
                
                // Add light to minimap scene
                const light = new THREE.DirectionalLight(0xffffff, 1);
                light.position.set(0, 1, 0);
                minimapScene.add(light);
                minimapScene.add(new THREE.AmbientLight(0xffffff, 0.5));
                
                // Player marker
                const playerMarker = new THREE.Mesh(
                    new THREE.ConeGeometry(5, 10, 8),
                    new THREE.MeshBasicMaterial({ color: 0xffff00 })
                );
                playerMarker.rotation.x = Math.PI / 2;
                minimapScene.add(playerMarker);
                
                return { playerMarker, terrainMesh };
            }
            
            const minimapObjects = createMinimapObjects();

            // Update minimap
            function updateMinimap() {
                minimapObjects.playerMarker.position.x = camera.position.x;
                minimapObjects.playerMarker.position.z = camera.position.z;
                minimapRenderer.render(minimapScene, minimapCamera);
            }

            return updateMinimap;
        }

        // Add collision detection function
        function checkCollision(position) {
            const height = getHeightAtPosition(position.x, position.z);
            const maxClimbableSlope = 1; // Maximum height difference player can climb
            const currentHeight = position.y - PLAYER_HEIGHT;
            
            // Check if trying to climb too steep
            if (Math.abs(height - currentHeight) > maxClimbableSlope) {
                return false;
            }
            return true;
        }

        // Add animal interaction function
        function interactWithAnimals() {
            const interactionRange = 5;
            const playerPosition = camera.position.clone();
            
            animals.forEach(animal => {
                const distance = playerPosition.distanceTo(animal.position);
                
                if (distance < interactionRange) {
                    switch(animal.userData.type) {
                        case 'deer':
                            // Deer runs away
                            animal.userData.state = 'running';
                            const awayVector = animal.position.clone()
                                .sub(playerPosition)
                                .normalize()
                                .multiplyScalar(2);
                            animal.userData.velocity.add(awayVector);
                            break;
                            
                        case 'bird':
                            // Bird takes flight
                            if (animal.position.y < 30) {
                                animal.userData.velocity.y = 1;
                            }
                            break;
                            
                        case 'duck':
                            // Duck quacks and splashes
                            if (!animal.userData.isQuacking) {
                                animal.userData.isQuacking = true;
                                animal.position.y += 0.5;
                                setTimeout(() => {
                                    animal.position.y -= 0.5;
                                    animal.userData.isQuacking = false;
                                }, 500);
                            }
                            break;
                            
                        case 'peacock':
                            // Peacock displays feathers
                            if (!animal.userData.isDisplaying) {
                                animal.userData.isDisplaying = true;
                                animal.children.forEach(child => {
                                    if (child.userData.isFeather) {
                                        child.rotation.x += Math.PI / 4;
                                    }
                                });
                                setTimeout(() => {
                                    animal.children.forEach(child => {
                                        if (child.userData.isFeather) {
                                            child.rotation.x -= Math.PI / 4;
                                        }
                                    });
                                    animal.userData.isDisplaying = false;
                                }, 2000);
                            }
                            break;
                    }
                }
            });
        }

        // Add this function to create a dragon
        function createDragon() {
            const dragon = new THREE.Group();
            
            // Body
            const bodyGeometry = new THREE.CapsuleGeometry(3, 8, 4, 8);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x8B0000 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.rotation.z = Math.PI / 2;
            dragon.add(body);
            
            // Head
            const headGeometry = new THREE.ConeGeometry(2, 4, 8);
            const head = new THREE.Mesh(headGeometry, bodyMaterial);
            head.position.set(5, 1, 0);
            head.rotation.z = -Math.PI / 2;
            dragon.add(head);
            
            // Wings
            const wingGeometry = new THREE.PlaneGeometry(10, 8);
            const wingMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x8B0000,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9
            });
            
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(0, 4, -4);
            leftWing.rotation.y = Math.PI / 4;
            dragon.add(leftWing);
            
            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.position.set(0, 4, 4);
            rightWing.rotation.y = -Math.PI / 4;
            dragon.add(rightWing);
            
            // Tail
            const tailGeometry = new THREE.CylinderGeometry(0.5, 0.1, 10);
            const tail = new THREE.Mesh(tailGeometry, bodyMaterial);
            tail.position.set(-6, 0, 0);
            tail.rotation.z = Math.PI / 6;
            dragon.add(tail);
            
            // Animation properties
            dragon.userData.flyingHeight = 100;
            dragon.userData.originalPosition = new THREE.Vector3(0, 100, 0);
            dragon.userData.time = 0;
            
            return dragon;
        }

        // Add this function to create a flower field
        function createFlowerField() {
            const flowers = new THREE.Group();
            const flowerColors = [0xFF69B4, 0xFFFF00, 0xFF0000, 0x800080, 0xFFA500];
            
            for (let i = 0; i < 1000; i++) {
                const x = Math.random() * 800 - 400;
                const z = Math.random() * 800 - 400;
                const y = getHeightAtPosition(x, z);
                
                if (y > 0 && y < 15) { // Only place flowers on suitable terrain
                    const flower = createFlower(flowerColors[Math.floor(Math.random() * flowerColors.length)]);
                    flower.position.set(x, y, z);
                    flower.scale.set(0.3, 0.3, 0.3);
                    flower.userData.isFlower = true;
                    flowers.add(flower);
                }
            }
            
            scene.add(flowers);
        }

        function createFlower(color) {
            const flower = new THREE.Group();
            
            // Stem
            const stemGeometry = new THREE.CylinderGeometry(0.1, 0.1, 2);
            const stemMaterial = new THREE.MeshPhongMaterial({ color: 0x00FF00 });
            const stem = new THREE.Mesh(stemGeometry, stemMaterial);
            flower.add(stem);
            
            // Petals
            const petalCount = 8;
            const petalGeometry = new THREE.PlaneGeometry(1, 0.5);
            const petalMaterial = new THREE.MeshPhongMaterial({ 
                color: color,
                side: THREE.DoubleSide
            });
            
            for (let i = 0; i < petalCount; i++) {
                const petal = new THREE.Mesh(petalGeometry, petalMaterial);
                const angle = (i / petalCount) * Math.PI * 2;
                petal.position.y = 1;
                petal.rotation.y = angle;
                flower.add(petal);
            }
            
            return flower;
        }

        // Add interaction text display
        function createInteractionText() {
            const div = document.createElement('div');
            div.style.position = 'absolute';
            div.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            div.style.color = 'white';
            div.style.padding = '5px';
            div.style.borderRadius = '5px';
            div.style.display = 'none';
            div.style.pointerEvents = 'none';
            document.body.appendChild(div);
            return div;
        }

        // Update mouse position
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        // Handle mouse click interactions
        function onMouseClick(event) {
            if (hoveredObject) {
                if (hoveredObject.userData.isFlower) {
                    // Make flower sway
                    const flower = hoveredObject;
                    flower.userData.swaying = true;
                    setTimeout(() => flower.userData.swaying = false, 2000);
                } else if (hoveredObject.userData.type === 'deer') {
                    // Make deer jump
                    const deer = hoveredObject;
                    deer.position.y += 2;
                    setTimeout(() => deer.position.y -= 2, 500);
                } else if (hoveredObject.userData.type === 'bird') {
                    // Make bird chirp and fly
                    const bird = hoveredObject;
                    bird.userData.velocity.y = 2;
                }
            }
        }
    </script>
</body>
</html> 
